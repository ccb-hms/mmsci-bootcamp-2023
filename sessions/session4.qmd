---
title: "Session 4: Transcriptomic Analysis"
format: html
---

# Limma

## Getting GEO data

```{r}
#   Differential expression analysis with limma
library(GEOquery)
library(limma)
library(umap)

my_id <- "GSE33126"
gse <- getGEO(my_id)
```

Some datasets on GEO may be derived from different microarray platforms. Therefore the object gse is a list of different datasets. You can find out how many were used by checking the length of the gse object. Usually there will only be one platform and the dataset we want to analyse will be the first object in the list (gse[[1]]).

```{r}
## check how many platforms used
length(gse)

## if more than one dataset is present, you can analyse the other dataset by changing the number inside the [[...]]
## e.g. gse <- gse[[2]]
gse <- gse[[1]]
gse
```

```{r, eval=FALSE}
pData(gse) ## print the sample information
fData(gse) ## print the gene annotation
exprs(gse) ## print the expression data
```


## Check scales and normalization

For visualisation and statistical analysis, we will inspect the data to discover what scale the data are presented in. The methods we will use assume the data are on a log~2~ scale; typically in the range of 0 to 16.

The `exprs` function can retrieve the expression values as a data frame; with one column per-sample and one row per-gene.

The `summary` function can then be used to print the distributions.

```{r}
## exprs get the expression levels as a data frame and get the distribution
summary(exprs(gse))
```

From this output we clearly see that the values go beyond 16, so we will need to perform a $log_2$ transformation. A `boxplot` can also be generated to see if the data have been normalised. If so, the distributions of each sample should be highly similar.

```{r}
exprs(gse) <- log2(exprs(gse))
boxplot(exprs(gse),outline=FALSE)
```

## Inspect the clinical variables

Data submitted to GEO contain sample labels assigned by the experimenters, and some information about the processing protocol. All these data can be extracted by the `pData` function. 

**For your own data, you will have to decide which columns will be useful in the analysis**. This will include the column giving the main comparison(s) of interest and any potential confounding factors. In this particular dataset it looks like `source_name_ch1` and `characteristics_ch1.1`.

We can use the `select` function from `dplyr` to display just these columns of interest. At this stage it will also be useful to rename the columns to something more convenient using the `rename` function.

```{r}
library(dplyr)
sampleInfo <- pData(gse)
sampleInfo

## source_name_ch1 and characteristics_ch1.1 seem to contain factors we might need for the analysis. Let's pick just those columns

sampleInfo <- select(sampleInfo, source_name_ch1,characteristics_ch1.1)

## Optionally, rename to more convenient column names
sampleInfo <- rename(sampleInfo,group = source_name_ch1, patient=characteristics_ch1.1)
```

Our sample information is therefore:-

```{r}
sampleInfo
```

## Sample clustering and Principal Components Analysis

Unsupervised analysis is a good way to get an understanding of the sources of variation in the data. It can also identify potential outlier samples.

The function `cor` can calculate the correlation (on scale 0 - 1) in a pairwise fashion between all samples. This can be then visualised on a heatmap. Among the many options for creating heatmaps in R, the `pheatmap` library is one of the more popular ones. The only argument it requires is a matrix of numerical values (such as the correlation matrix).

```{r}
library(pheatmap)
## argument use="c" stops an error if there are any missing data points

corMatrix <- cor(exprs(gse),use="c")
pheatmap(corMatrix)                
```

We can incorporate sample information onto the plot to try and understand the clustering. We have already created such a data frame previously (`sampleInfo`). However, we need to take care that the rownames of these data match the columns of the correlation matrix.

```{r}
## Print the rownames of the sample information and check it matches the correlation matrix
rownames(sampleInfo)
colnames(corMatrix)

## If not, force the rownames to match the columns

rownames(sampleInfo) <- colnames(corMatrix)
pheatmap(corMatrix,
         annotation_col=sampleInfo)    
```

Here we see that the main separation is due to normal vs tumours; as we hope.

A complementary approach is to use Principal Components Analysis (PCA). There is a nice explanation in this youtube video.

https://www.youtube.com/watch?v=0Jp4gsfOLMs

It is important to *transpose* the expression matrix, otherwise R will try and compute PCA on the genes (instead of samples) and quickly run out of memory.

As PCA is an unsupervised method, the known sample groups are not taken into account. However, we can add labels when we plot the results. The `ggplot2` package is particularly convenient for this. The `ggrepel` package can be used to postion the text labels more cleverly so they can be read.

```{r}
library(ggplot2)
library(ggrepel)
## MAKE SURE TO TRANSPOSE THE EXPRESSION MATRIX

pca <- prcomp(t(exprs(gse)))

## Join the PCs to the sample information
cbind(sampleInfo, pca$x) %>% 
ggplot(aes(x = PC1, y=PC2, col=group,label=paste("Patient", patient))) + geom_point() + geom_text_repel()
```

**What happens if we spot a batch effect?**

Nothing at this stage. Provided the experimental design is sensible (i.e. representatives from all samples groups are present in each batch) we can correct for batch when we run the differential expression analysis.

**What happens if we detect outliers?**

If we suspect some samples are outliers we can remove them for further analysis

## Differential Expression

By far the most-popular package for performing differential expression is `limma`. The user-guide is extensive and covers the theory behind the analysis and many use-cases (Chapters 9 and 17 for single-channel data such as Illumina and Affymetrix)

https://bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf

Crucially, we have to allocate the samples in our dataset to the sample groups of interest. A useful function is  `model.matrix`, which will create a *design matrix* from one of the columns in your `sampleInfo`. Here I choose `sampleInfo$group`.

The design matrix is a matrix of `0` and `1`s; one row for each sample and one column for each sample group. A `1` in a particular row and column indicates that a given sample (the row) belongs to a given group (column).

```{r}
library(limma)
design <- model.matrix(~0+sampleInfo$group)
design
## the column names are a bit ugly, so we will rename
colnames(design) <- c("Normal","Tumour")
```

It has been demonstrated that our power to detect differential expression can be improved if we filter lowly-expressed genes prior to performing the analysis. Quite how one defines a gene being expressed may vary from experiment to experiment, so a cut-off that will work for all datasets is not feasible. Here we consider that aroudn 50% of our genes will not be expressed, and use the median expression level as a cut-off.

```{r eval=FALSE}
summary(exprs(gse))

## calculate median expression level
cutoff <- median(exprs(gse))

## TRUE or FALSE for whether each gene is "expressed" in each sample
is_expressed <- exprs(gse) > cutoff

## Identify genes expressed in more than 2 samples

keep <- rowSums(is_expressed) > 2

## check how many genes are removed / retained.
table(keep)

## subset to just those expressed genes
gse <- gse[keep,]
```



The `lmFit` function is used to fit the model to the data. The result of which is to estimate the expression level in each of the groups that we specified.

```{r}
fit <- lmFit(exprs(gse), design)
head(fit$coefficients)
```

In order to perform the *differential* analysis, we have to define the contrast that we are interested in. In our case we only have two groups and one contrast of interest. Multiple contrasts can be defined in the `makeContrasts` function.

```{r}
contrasts <- makeContrasts(Tumour - Normal, levels=design)

## can define multiple contrasts
## e.g. makeContrasts(Group1 - Group2, Group2 - Group3,....levels=design)

fit2 <- contrasts.fit(fit, contrasts)
```

Finally, apply the *empirical Bayes'* step to get our differential expression statistics and p-values.

```{r}
fit2 <- eBayes(fit2)
```

We usually get our first look at the results by using the `topTable` command

```{r}
topTable(fit2)
```

The `topTable` function automatically displays the results for the first contrast. If you want to see results for other contrasts
```{r}
topTable(fit2, coef=1)
### to see the results of the second contrast (if it exists)
## topTable(fit2, coef=2)

```

If we want to know how many genes are differentially-expressed overall we can use the `decideTests` function.

```{r}
decideTests(fit2)

table(decideTests(fit2))
```

 DESeq2

## Summarized Experiment

This section introduces another broadly useful package and data structure, the [SummarizedExperiment](https://bioconductor.org/packages/SummarizedExperiment) package and `SummarizedExperiment` object.

The `SummarizedExperiment` object has matrix-like properties -- it has two dimensions and can be subset by 'rows' and 'columns'. The `assay()` data of a `SummarizedExperiment` experiment contains one or more matrix-like objects where rows represent features of interest (e.g., genes), columns represent samples, and elements of the matrix represent results of a genomic assay (e.g., counts of reads overlaps genes in each sample of an bulk RNA-seq differential expression assay.

**Object construction**

The `SummarizedExperiment` coordinates assays with (optional) descriptions of rows and columns. We start by reading in a simple `data.frame` describing 8 samples from an RNASeq experiment looking at dexamethasone treatment across 4 human smooth muscle cell lines; use `browseVignettes("airway")` for a more complete description of the experiment and data processing. Read the column data in using `file.choose()` and `read.csv()`.

```{r, eval=FALSE}
#fname <- file.choose()  # airway_colData.csv
#fname
```

```{r, echo=FALSE}
fname <- "../data/airway_colData.csv"
```

We want the first column the the data to be treated as row names (sample identifiers) in the `data.frame`, so `read.csv()` has an extra argument to indicate this.

```{r}
colData <- read.csv(fname, row.names = 1)
head(colData)
```

The data are from the Short Read Archive, and the row names, `SampleName`, `Run`, `Experiment`, `Sampel`, and `BioSample` columns are classifications from the archive. Additional columns include:

-   `cell`: the cell line used. There are four cell lines.
-   `dex`: whether the sample was untreated, or treated with dexamethasone.
-   `albut`: a second treatment, which we ignore
-   `avgLength`: the sample-specific average length of the RNAseq reads estimated in the experiment.

**Assay data**

Now import the assay data from the file "airway_counts.csv"

```{r, eval=FALSE}
fname <- file.choose()  # airway_counts.csv
fname
```

```{r, echo=FALSE}
fname <- "../data/airway_counts.csv"
```

```{r}
counts <- read.csv(fname, row.names=1)
```

Although the data are read as a `data.frame`, all columns are of the same type (integer-valued) and represent the same attribute; the data is really a `matrix` rather than `data.frame`, so we coerce to matrix using `as.matrix()`.

```{r}
counts <- as.matrix(counts)
```

We see the dimensions and first few rows of the counts matrix

```{r}
dim(counts)
head(counts)
```

It's interesting to think about what the counts mean -- for ENSG00000000003, sample SRR1039508 had 679 reads that overlapped this gene, sample SRR1039509 had 448 reads, etc. Notice that for this gene there seems to be a consistent pattern -- within a cell line, the read counts in the untreated group are always larger than the read counts for the treated group. This and other basic observations from 'looking at' the data motivate many steps in a rigorous RNASeq differential expression analysis.

**Creating a `SummarizedExperiment` object**

There is considerable value in tightly coupling of the column data with the assay data, as it reduces the chances of bookkeeping errors as we work with our data.

Attach the [SummarizedExperiment](https://bioconductor.org/packages/SummarizedExperiment) library to our *R* session.

```{r, message=FALSE}
library("SummarizedExperiment")
```

Use the `SummarizedExperiment()` function to coordinate the assay and column data; this function uses row and column names to make sure the correct assay columns are described by the correct column data rows.

```{r}
se <- SummarizedExperiment(assay = list(count=counts), colData = colData)
se
```

It is straight-forward to use `subset()` on `SummarizedExperiment` to create subsets of the data in a coordinated way. Remember that a `SummarizedExperiment` is conceptually two-dimensional (matrix-like), and in the example below we are subsetting on the second dimension.

```{r}
subset(se, , dex == "trt")
```

There are also accessors that extract data from the `SummarizedExperiment`. For instance, we can use `assay()` to extract the count matrix, and `colSums()` to calculate the library size (total number of reads overlapping genes in each sample).

```{r}
colSums(assay(se))
```

Note that library sizes differ by a factor of 2 from largest to smallest; how would this influence the interpretation of counts in individual cells of the assay data?

It might be useful to remember important computations in a way that is robust, e.g.,

```{r}
se$lib.size <- colSums(assay(se))
colData(se)
```

**Exercises**

::: {.callout-note appearance="simple" icon="false"}
## Basic

1.  Subset the `SummarizedExperiment` object `se` created above to genes (rows) with at least 8 reads mapped across all samples.

*Hint: use `rowSums`.*

2.  Scale the read counts by library size, i.e. divide each column of `assay(se)` by the corresponding `lib.size` of each sample (column). Multiply the resulting scaled counts by `10^6` to obtain counts per million reads mapped.
:::

::: {.callout-tip icon="false" collapse="true"}
## Solution

```{r}
#1
#Method 1
rs <- rowSums(assay(se))
se.sub <- subset(se, rs>7,)
#Method 2
ind <- rowSums(assay(se)) >= 8
se.sub <- se[ind,]
#2
# scale by library size
# option 1: loop  
for(i in 1:8)
  assay(se.sub)[,i] <- assay(se.sub)[,i] / se$lib.size[i]
assay(se.sub)[1:5,1:5]
# option 2: vectorized
se.sub <- se[ind,]
tassay <- t(assay(se.sub)) / se$lib.size
assay(se.sub) <- t(tassay)
assay(se.sub)[1:5,1:5]

# counts per million reads mapped
assay(se.sub) <- assay(se.sub) * 10^6
assay(se.sub)[1:5,1:5]


ind <- rowSums(assay(se)) >= 8
se.sub <- se[ind,]
nrow(se.sub)

```
:::

## Differential Analysis

A basic task in the analysis of RNA-seq count data is the detection of differentially expressed genes. The count data are presented as a table which reports, for each sample, the number of sequence fragments that have been assigned to each gene. An important analysis question is the quantification and statistical inference of systematic changes between conditions, as compared to within-condition variability.

We start by loading the [DESeq2](https://bioconductor.org/packages/DESeq2) package, a very popular method for analysing differential expression of bulk RNA-seq data.

```{r, message=FALSE}
library("DESeq2")
```

[DESeq2](https://bioconductor.org/packages/DESeq2) requires count data like that in the `SummarizedExperiment` we have been working with.

The [airway](https://bioconductor.org/packages/airway) experimental data package contains an example dataset from an RNA-Seq experiment of read counts per gene for airway smooth muscles. These data are stored in a `RangedSummarizedExperiment` object which contains 8 different experimental samples and assays 64,102 gene transcripts.

```{r, message=FALSE}
library(airway)
data(airway)
se <- airway
se
rowRanges(se)
colData(se)
```

The package requires count data like that in the `SummarizedExperiment` we have been working with, in addition to a `formula` describing the experimental design. We use the cell line as a covariate, and dexamethazone treatment as the main factor that we are interested in.

```{r}
dds <- DESeqDataSet(se, design = ~ cell + dex)
dds
```

The `dds` object can be manipulated very much like a `SummarizedExperiment` (in fact: it *is* a `SummarizedExperiment`).

There are two reasons which make pre-filtering useful: by removing genes with only few reads across samples, we reduce the size of the `dds` data object, and thus increase the speed of the transformation and testing functions within DESeq2.

Here we perform a minimal pre-filtering to keep only rows that have at least 10 reads total.

```{r}
keep <- rowSums(counts(dds)) >= 10
table(keep)
dds <- dds[keep,]
```

The DESeq workflow is summarized by a single function call, which performs statistical analysis on the data in the `dds` object.

```{r}
dds <- DESeq(dds)
```

A table summarizing measures of differential expression can be extracted from the object, and visualized or manipulated using commands we learned earlier.

```{r}
res <- results(dds)
res
```

**Task**:

Use the `contrast` argument of the `results` function to compare `trt` vs. `untrt` groups instead of `untrt` vs. `trt` (changes the direction of the fold change).

::: {.callout-tip icon="false" collapse="true"}
## Solution

```{r}
res_trt_untrt <- results(dds, contrast = c("dex","trt","untrt"))
```
:::

## Volcano plot

A useful illustration of differential expression results is to plot the fold change against the *p*-value in a volcano plot. This allows to inspect direction and magnitude (fold change) as well as the statistical significance (*p*-value) of the expression change.

```{r, message = FALSE}
library(ggplot2)
ggplot(as.data.frame(res), 
       aes(x = log2FoldChange, y = -log10(padj))) + 
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "red") +
  geom_vline(xintercept = -1, col = "red") +
  geom_vline(xintercept = 1, col = "red")
```

## MA plot

Another useful illustration of differential expression results is to plot the fold changes as a function of the mean of the expression level (normalized counts) across samples in an MA plot.

Points will be colored if the adjusted *p*-value is less than a defined significance threshold (default: 0.1). Points which fall out of the window are plotted as open triangles pointing either up or down.

```{r}
plotMA(res)
```

The [DESeq2](https://bioconductor.org/packages/DESeq2) vignette also describes several other useful result exploration and data quality assessment plots.

**Exercises**

::: {.callout-note appearance="simple" icon="false"}
## Basic

1.  Use the `coef` function to examine the actual coefficients of the model.

2.  Get the number of genes considered significantly expressed at the alpha level of 0.1 (for the adjusted p value).

3.  Now see how many genes would be considered differentially expressed at an alpha level of 0.05 and a log2 fold change cutoff of at least 1. **Note**: Take a look again at the arguments of the `results` function. Are there any you should change?
:::

::: {.callout-tip icon="false" collapse="true"}
## Solution

```{r}
#| eval: false
#1.  Use the `coef` function to examine the actual coefficients of the model.
coef(dds)

#2.  
sum(res$padj<0.1, na.rm = TRUE)

#3. 
res_05_1 <- results(dds, alpha=0.05,lfcThreshold = 1)
sum((res_05_1$padj<0.1)&(res_05_1$log2FoldChange>=1), na.rm = TRUE)
```
:::


::: {.callout-caution appearance="simple" icon="false"}
## Advanced

Let's imagine that, instead of all being untreated, half of the samples had been treated with albuterol:

```{r}
#| eval: false
fake_se <- se
#Currently the factor only has the untrt level, so we need to add another
levels(colData(fake_se)$albut) <- c(levels(colData(fake_se)$albut), "trt")
colData(fake_se)$albut[c(1,3,4,8)] <- "trt"
```

Remake the `dds` object such that the `albut` column is an additional covartiate in the experimental design.

If there is time, compare the number of significant results (for comparing `cell` and `dex`) when `albut` is and is not accounted for. Does it make a difference?
:::

::: {.callout-tip icon="false" collapse="true"}
## Solution

```{r}
#| eval: false
dds_fake <- DESeqDataSet(fake_se, design = ~ albut + cell + dex)
keep <- rowSums(counts(dds_fake)) >= 4
dds_fake <- dds_fake[keep,]
dds_fake <- DESeq(dds_fake)
res_fake <- results(dds_fake)

sum(res$padj<0.1, na.rm = TRUE)
sum(res_fake$padj<0.1, na.rm = TRUE)
```
:::
